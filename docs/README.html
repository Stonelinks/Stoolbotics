<html>
<head>

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" href="static/bootstrap.min.css">
    <style type="text/css">
      html, body {
        background-color: #ddd;
      }
      body {
        padding: 40px;
      }
      .container {
        width: 820px;
      }
      .content {
        background-color: #fff;
        padding: 20px;
        margin: 0 -20px;
        -webkit-border-radius: 16px;
           -moz-border-radius: 16px;
                border-radius: 16px;
        -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);
           -moz-box-shadow: 0 1px 2px rgba(0,0,0,.15);
                box-shadow: 0 1px 2px rgba(0,0,0,.15);
                
      }
    </style>

    <title>Stoolbotics Documentation</title>

</head>
<body>

<div class="container">
<div class="content">
<h1>Welcome to Stoolbotics!</h1>

<p>Luke Doyle and Scott Peck</p>
<div class="toc">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#welcome">Welcome</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#getting-stoolbotics">Getting Stoolbotics</a><ul>
<li><a href="#for-windows">For Windows</a><ul>
<li><a href="#prebuilt-recommended">Prebuilt (recommended)</a></li>
<li><a href="#from-source">From Source</a></li>
</ul>
</li>
<li><a href="#for-linux">For Linux</a></li>
<li><a href="#for-mac-osx">For Mac OSX</a></li>
</ul>
</li>
<li><a href="#quickstart">Quickstart</a></li>
</ul>
</li>
<li><a href="#using-the-simulator">Using the Simulator</a><ul>
<li><a href="#specifying-a-robot">Specifying a Robot</a><ul>
<li><a href="#robotjson-file">Robot.json File</a></li>
<li><a href="#loading-a-robot-into-the-simulator">Loading a robot into the simulator</a></li>
</ul>
</li>
<li><a href="#command-overview">Command Overview</a></li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#changing-the-environment">Changing the Environment</a></li>
<li><a href="#skew-mode">Skew mode</a></li>
<li><a href="#set">Set</a></li>
<li><a href="#playback-and-recording">Playback and Recording</a><ul>
<li><a href="#file-format">File Format</a></li>
<li><a href="#recording">Recording</a></li>
<li><a href="#playback">Playback</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#symbolics">Symbolics</a></li>
<li><a href="#kinematics">Kinematics</a></li>
<li><a href="#time-stepping">Time-stepping</a></li>
<li><a href="#drawing-the-robot">Drawing the Robot</a><ul>
<li><a href="#joints">Joints</a></li>
<li><a href="#links">Links</a></li>
</ul>
</li>
<li><a href="#terminal-implementation">Terminal Implementation</a></li>
</ul>
</li>
<li><a href="#closing-remarks">Closing Remarks</a><ul>
<li><a href="#future-improvements">Future Improvements</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="introduction">Introduction</h1>
<h2 id="welcome">Welcome</h2>
<p>Hello and welcome to the Stoolbotics documentation! Stoolbotics is a general purpose robotic arm and kinematics simulator aimed at being a teaching tool for aspiring roboticists. The motivation for this project was simple: the linear algebra and mathematical concepts behind robotics is difficult for a beginner to understand without any visual context. This is especially true for people who are primarily visual learners.</p>
<p>This tool will hopefully fill a gap in many higher education robotics classrooms. It was designed to be easy to use and compatible with other technologies (like MATLAB). The project itself was conceived halfway through the Fall 2011 semester at RPI by Lucas Doyle, and the implementation was carried out by Lucas Doyle and Scott Peck.</p>
<h2 id="features">Features</h2>
<p>Stoolbotics has many features that make it attractive to the aspiring roboticst and the higer education robotics classrom. To name a few, Stoolbotics features:</p>
<ul>
<li>Easy to use file format for specifying a robot arm</li>
<li>Ability to visualize any robot that can be specified in such a file</li>
<li>Compute the forward kinematics of any robot</li>
<li>Animate and draw paths for arms</li>
<li>Command line interface within simulator with many useful commands</li>
<li>Completely customizable simulation environment (time-stepping, etc)</li>
<li>Ability to record simulator activity</li>
<li>Ability to playback saved recordings, or even import a recording generated in MATLAB</li>
<li>Change variables in the simulator on the fly</li>
<li>Built in help from simulator command line, and of course this stellar and complete documentation</li>
<li>Cross platform implementation</li>
</ul>
<h2 id="getting-stoolbotics">Getting Stoolbotics</h2>
<h3 id="for-windows">For Windows</h3>
<h4 id="prebuilt-recommended">Prebuilt (recommended)</h4>
<p>Stoolbotics comes in a pre-packaged, portable build for Windows. You can download it from Lucas' Dropbox here: <a href="http://dl.dropbox.com/u/4428042/simulator.zip">http://dl.dropbox.com/u/4428042/simulator.zip</a>.</p>
<p>Simply unzip and run <code>stoolbotics.bat</code>, and you should be up and running!</p>
<h4 id="from-source">From Source</h4>
<p>If you're feeling more adventurous, or want to develop Stoolbotics for Windows, you can still run the simulator through python from the command prompt. You will need to install a few dependencies though. Python (2.7 works best), Numpy, PyOpenGL and (optionally) the python imaging library (PIL) need to all be installed. If you choose not to install PIL, the only functionality that will be effected is the ability to take screenshots from within the simulator.</p>
<p>Once you have everything above installed, you should <a href="https://github.com/Stonelinks/Stoolbotics/zipball/master">download the latest zip</a> of our code repository from github. Once you have it downloaded, just unzip and run <code>python simulator.py</code> in the simulator directory.</p>
<h3 id="for-linux">For Linux</h3>
<p>Make sure you have Python, Git, Numpy, PyOpenGL and (optionally) the python imaging library (PIL) installed. Using pip, python's distutils, or your Linux distributions package manager is appropriate here. If you choose not to install PIL, the only functionality that will be affected is the ability to take screenshots from within the simulator.</p>
<p>Next, make a clone of our repository by running <code>git clone https://github.com/Stonelinks/Stoolbotics.git</code>, then just run <code>sh Stoolbotics.sh</code> to fire up the simulator. Any time you wish to update, just run <code>git pull</code> from inside the repository.</p>
<h3 id="for-mac-osx">For Mac OSX</h3>
<p>OSX isn't officially supported as we don't have a machine we can test on, but if you have a python installation with PyOpenGL, Numpy, and PIL then there is no reason why following the Linux instructions above wouldn't work.</p>
<p>If you just want to grab a copy of the code, you can <a href="https://github.com/Stonelinks/Stoolbotics/zipball/master">download the latest zip</a> of our code repository from github.</p>
<h2 id="quickstart">Quickstart</h2>
<p>When you fire up the simulator for the first time, you should see something like what is shown below.</p>
<img src="https://github.com/Stonelinks/Stoolbotics/raw/master/docs/static/1.png" width="780px" height="540px">

<p>You'll notice a robot is loaded into the simulator to start with. This simple three joint arm is called the Phantom Omni, and is defined by the <code>omni.json</code> file in the <code>robots</code> directory. All robot files that the simulator uses are described in such <code>robot.json</code> files in the <code>robots</code> directory. They are simple and easy to understand. Below we have reproduced <code>omni.json</code> as it is first loaded into the simulator:</p>
<pre>
        "N" : "3",

"h1" : "z",
        "h2" : "x",
        "h3" : "x",

"q1" : ".1*t",
        "q2" : ".1*cos(t)",
        "q3" : ".001*t + .2*sin(t)",

"l1" : "40",
        "l2" : "50",
        "l3" : "50",

"P01" : "[0, 0, 0]",
        "P12" : "[0, 0, l1]",
        "P23" : "[0, l2, 0]",
        "P3T" : "[0, l3, 0]",

"R01" : "rot(h1, q1)",
        "R12" : "rot(h2, q2)",
        "R23" : "rot(h3, q3)",
        "R3T" : "eye(3, 3)"
</pre>

<p>Let’s look at this file line by line to see how it makes a complete robot object:</p>
<ul>
<li><code>N</code> is first declared to tell the simulator the number of joints to expect in this robot.</li>
<li>All the joint axes are specified with an <code>h</code> and an index. In this case, shorthand is used (e.g. use of <code>z</code> instead of <code>[0, 0, 1]</code>), but if we wanted a non-standard axis vector we could have used something like <code>[-.1, .2, .4]</code>.</li>
<li>Angle parameters are specified with a <code>q</code> and an index. These can be completely arbitrary functions of time, static numbers, or whatever you like. These parameters represent how much an axis has rotated or displaced along its axis.</li>
<li>Link lengths are specified with an <code>l</code> and an index.</li>
<li>Position vectors tell the simulator how to get from one frame to the next. Additionally, prismatic joints are specified here by including a joint axis parameter (a <code>q</code>) in the vector.</li>
<li>Finally, the rotation matrices are specified by using the <code>rot()</code> command, which calculates the rotation matrix using the Euler-Rodriguez formula. If no rotation is desired, just specify the identity matrix with the <code>eye()</code> command. Sometimes, for static links it is necessary to specify extra frames that don't have any rotation matrix. If this is the case, you would also just use the <code>eye()</code> command here.</li>
</ul>
<p>All these variables can be changed once the simulator has started using the <code>set</code> command. There are many more commands available to you in the simulator that can be accessed through the command line. To see a list of them, just type <code>help</code> into the console and you should see a list like what’s below. To view help about a specific command, just type <code>help &lt;command&gt;</code>. A table showing what all the commands are, their syntax, and what they do is also included later on in this documentation.</p>
<img src="https://github.com/Stonelinks/Stoolbotics/raw/master/docs/static/3.png" width="780px" height="540px">

<p>In the above case, we looked at the help for the <code>axis</code> command. Let’s see what it actually does:</p>
<img src="https://github.com/Stonelinks/Stoolbotics/raw/master/docs/static/4.png" width="780px" height="540px">

<p>It is clear then that the axis command can be used to turn on and off the the axis for each intermediary joint coordinate frame. There are many other commands that can be used to manipulate the cosmetics of the simulation environment. These are all covered later in an example section on manipulating the environment. For now though, let’s check out another command, the <code>play</code> command. A simulator is pretty useless unless it can actually simulate things. The <code>play</code> command starts the simulation:</p>
<img src="https://github.com/Stonelinks/Stoolbotics/raw/master/docs/static/5.png" width="780px" height="540px">

<p>To stop the simulator, just type <code>stop</code>. All the variables we set earlier are still modifiable during the runtime. To set these, we use the <code>set</code> command. For example, let’s set q3 to cos(t) by typing <code>set q3 cos(t)</code> into the command prompt:</p>
<img src="https://github.com/Stonelinks/Stoolbotics/raw/master/docs/static/6.png" width="780px" height="540px">

<p>Though you can't see it in a static picture, that joint is now moving pretty fast. Let’s use the <code>set</code> command again to slow it down. Type <code>set tscale .05</code> command and notice that it now goes slower. The value of an appropriate timescale may vary depending on how fast your computer is. <code>skew</code> mode can be enabled to rapidly adjust timescale as well as other parameters. For now though, just use <code>set</code>: </p>
<img src="https://github.com/Stonelinks/Stoolbotics/raw/master/docs/static/7.png" width="780px" height="540px">

<p>This concludes the quickstart. To do more advanced things like play, record, manipulate the environment, etc., check out the examples section!</p>
<h1 id="using-the-simulator">Using the Simulator</h1>
<h2 id="specifying-a-robot">Specifying a Robot</h2>
<h3 id="robotjson-file">Robot.json File</h3>
<p>As covered in the quickstart, robots are specified in json files that contain sections in it for defining various aspects of a robot to be simulated. Here is an example file for the Phantom Omni and the explanation again in case you skipped over the quickstart:</p>
<pre>
        "N" : "3",

"h1" : "z",
        "h2" : "x",
        "h3" : "x",

"q1" : ".1*t",
        "q2" : ".1*cos(t)",
        "q3" : ".001*t + .2*sin(t)",

"l1" : "40",
        "l2" : "50",
        "l3" : "50",

"P01" : "[0, 0, 0]",
        "P12" : "[0, 0, l1]",
        "P23" : "[0, l2, 0]",
        "P3T" : "[0, l3, 0]",

"R01" : "rot(h1, q1)",
        "R12" : "rot(h2, q2)",
        "R23" : "rot(h3, q3)",
        "R3T" : "eye(3, 3)"
</pre>

<ul>
<li><code>N</code> is first declared to tell the simulator the number of joints to expect in this robot.</li>
<li>All the joint axes are specified with an <code>h</code> and an index. In this case, shorthand is used (e.g. use of <code>z</code> instead of <code>[0, 0, 1]</code>), but if we wanted a non-standard axis vector we could have used something like <code>[-.1, .2, .4]</code>.</li>
<li>Angle parameters are specified with a <code>q</code> and an index. These can be completely arbitrary functions of time, static numbers, or whatever you like. These parameters represent how much an axis has rotated or displaced along its axis.</li>
<li>Link lengths are specified with an <code>l</code> and an index.</li>
<li>Position vectors tell the simulator how to get from one frame to the next. Additionally, prismatic joints are specified here by including a joint axis parameter (a <code>q</code>) in the vector.</li>
<li>Finally, the rotation matrices are specified by using the <code>rot()</code> command, which calculates the rotation matrix using the Euler-Rodriguez formula. If no rotation is desired, just specify the identity matrix with the <code>eye()</code> command. Sometimes, for static links it is necessary to specify extra frames that don't have any rotation matrix. If this is the case, you would also just use the <code>eye()</code> command here.</li>
</ul>
<h3 id="loading-a-robot-into-the-simulator">Loading a robot into the simulator</h3>
<p>First, all robots are pulled from the <code>robots</code> directory in the root directory of the simulator. It is reccomended to actually copy an existing robot file and modify it to suit your needs.</p>
<p>Writing and/or modifying one of these files is for the most part a straightforward process. The only hiccup you may encounter is in specifying extra frames in order to get the simulator to handle extra links. Additionally, another interesting way of specifying robots is by programmaticly generating a json file. An example of this can be seen with <code>snake.py</code> which generates <code>snake.json</code>.</p>
<p>Once you have written a robot.json file, there are two commands that will help you out getting it into the simulator. First, use the <code>list</code> command to see all robot configuration files that the simulator believes to be properly configured and placed correctly. You should see a list containing the Omni, Puma560, etc. and whatever else you have put in the robots directory. Next, use the <code>load</code> command to load your robot.</p>
<h2 id="command-overview">Command Overview</h2>
<table><tr><td><h4 style="width: 100px;">Command</h4></td><td><h4 style="width: 300px;">Usage</h4></td><td><h4>Description</h4></td></tr><tr><td><b>axis</b></td><td><b>axis &lt;on/off&gt;</b></td><td>Turn robot axis on/off. Providing no arguments toggles the axis.</td></tr><tr><td><b>eval</b></td><td><b>eval &lt;expression&gt;</b></td><td>Return some variable from the simulator. e.g. 'eval robot.P01'. Output might look a little weird.</td></tr><tr><td><b>exit</b></td><td><b>exit or quit</b></td><td>Closes the simulator.</td></tr><tr><td><b>floor</b></td><td><b>floor &lt;on/off&gt;</b></td><td>Turns the floor on and off. Providing no arguments toggles the floor.</td></tr><tr><td><b>ghost</b></td><td><b>ghost &lt;on/off/interval&gt; &lt;number&gt;</b></td><td>turn robot ghosts on/off. If &lt;interval&gt; is present, provide a number to set the ghost interval. Providing no arguments toggles the ghosts.</td></tr><tr><td><b>help</b></td><td><b>help &lt;cmd (optional)&gt;</b></td><td>If &lt;cmd&gt; is provided, display help for that command. Otherwise  it just list all commands.</td></tr><tr><td><b>hide</b></td><td><b>hide</b></td><td>Hides this terminal.</td></tr><tr><td><b>list</b></td><td><b>list</b></td><td>Lists all the robots that can be loaded into the simulator. To add something to this list, just place a valid robot.json file in the 'robots' folder.</td></tr><tr><td><b>load</b></td><td><b>load &lt;robot file&gt;</b></td><td>Loads a robot file into the simulator. Use the 'list' command to see what robots are able to be loaded.</td></tr><tr><td><b>play</b></td><td><b>play &lt;file (optional)&gt;</b></td><td>If &lt;file&gt; is present, the simulator plays that file. Otherwise, it just starts the simulator.</td></tr><tr><td><b>record</b></td><td><b>record &lt;file&gt;</b></td><td>Outputs current arm movements to a file which can be exported or played back later.</td></tr><tr><td><b>screendump</b></td><td><b>screendump</b></td><td>Take a picture of the current screen and save it to disk.</td></tr><tr><td><b>set</b></td><td><b>set &lt;var&gt; &lt;expression&gt;</b></td><td>Sets a symbolic variable in the simulator. e.g. 'set q3 cos(t)', 'set t 0', 'set tscale -.1', 'set P23 [0, 0, l2 + q2]'.</td></tr><tr><td><b>skew</b></td><td><b>skew</b></td><td>Enters skew mode, where the view of the robot and simulation speed can be rapidly adjusted.</td></tr><tr><td><b>status</b></td><td><b>status</b></td><td>Tells you what the simulator is currently doing.</td></tr><tr><td><b>stop</b></td><td><b>stop</b></td><td>Halts the simulation.</td></tr><tr><td><b>trace</b></td><td><b>trace &lt;on/off/clear/limit&gt; &lt;number&gt;</b></td><td>Turn robot traces on/off, or clear the current set of traces. If the &lt;limit&gt; argument is used, provide a number to set the maximum number of traces.</td></tr></table>

<h2 id="examples">Examples</h2>
<h3 id="changing-the-environment">Changing the Environment</h3>
<p>The cosmetics of the simulation environment are highly configurable. Here are some of the commands that can modify the appearance:</p>
<ul>
<li>Axis<ul>
<li>The joint coordinate frame axis display can be turned on and off with the use of the <code>axis</code> command.</li>
</ul>
</li>
<li>Floor<ul>
<li>The floor in the simulator can be turned on and off with the use of the <code>floor</code> command.</li>
</ul>
</li>
<li>Ghosts<ul>
<li>A 'ghost' is a shadow of a robot in a previous articulated position. Use the <code>ghost</code> command to control them.</li>
<li>The interval of when ghosts appear can be set with <code>ghost interval &lt;somenumber&gt;</code>.</li>
</ul>
</li>
<li>Traces<ul>
<li>The trace that the robot leaves behind is completely configurable with the <code>trace</code> command.</li>
<li>The number of traces saved can be set by executing <code>trace limit &lt;somenumber&gt;</code>.</li>
<li>Finally, traces can get kind of ugly and annoying sometimes, so it is nice to be able to clear them by running <code>trace clear</code>.</li>
</ul>
</li>
</ul>
<p>Here is an example of some simulation environment manipulation with the above commands and the result:</p>
<img src="https://github.com/Stonelinks/Stoolbotics/raw/master/docs/static/8.png" width="780px" height="540px">

<h3 id="skew-mode">Skew mode</h3>
<p>Skew mode allows you to rapidly adjust where the camera is positioned in the simulation as well as adjust the timestep. To enter skew mode, just type <code>skew</code>. From there you can use the arrow keys to translate the camera up or down, use 'f' and 'd' to speed up or slow down the simulation, and finally 'j' and 'k' to zoom in and out. While in skew mode, none of the other commands work, so to exit you need to type 't'. Its hard to show a picture of skew mode in action.</p>
<h3 id="set">Set</h3>
<p>As you can see from the quickstart, the set command is highly versatile. You can set any variable in the simulator or the robot with this command. Here are some examples of clever ways to use the set command:</p>
<table><tr><td><h4 style="width: 300px;">Command</h4></td><td><h4>Effect</h4></td></tr>
<tr>
<td><pre>set t 0</pre></td>
<td>Resets the time in the simulator back to time = 0.</td>
</tr>

<tr>
<td><pre>set tscale 0.05</pre></td>
<td>Manually sets the timescale in the simulator (the same effect could also be done with the skew command).</td>
</tr>

<tr>
<td>
<pre>
set q1 0
set q2 0
set q3 0
(etc ...)
</pre>
</td>
<td>Sets all joints in the robot to zero position.</td>
</tr>

<tr>
<td>
<pre>
set h1 x
set h2 [1, 1, 1]
set h3 z
(etc ...)
</pre>
</td>
<td>Sets all joints axis in the robot to arbitrary vectors. Use of shortcuts like "x" is entirely optional, you can do things like [1, 0, 0] and accomplish the same effect.</td>
</tr>

<tr>
<td>
<pre>
set l1 50
</pre>
</td>
<td>Set link one to be 50.</td>
</tr>

<tr>
<td>
<pre>
set P12 [0, 0, l2 + q2]
</pre>
</td>
<td>Make a prismatic joint in the Z direction from frame one to frame two.</td>
</tr>

<tr>
<td>
<pre>
set R12 eye(3, 3)
</pre>
</td>
<td>Sets R12 to be the identity matrix, effectively creating a static link.</td>
</tr>
</table>

<h3 id="playback-and-recording">Playback and Recording</h3>
<p>The simulator also includes functionality to play back and record robot motion through the <code>play</code> and <code>record</code> commands.</p>
<h4 id="file-format">File Format</h4>
<p>The file format that Stoolbotics uses to store robot activity is very straightforward. It is a standard .csv file, where each row is a slice of time. The first entry in each row is always time, but since the timescale can be adjusted in the simulator, this column almost doesn't matter. The remaining entries in the row corresponds to joint angles (in radians) starting from the first joint out to the end of the arm. An example snippet for a three joint arm is shown below:</p>
<pre>

0.0, 0.1, 0.0540302305868, 0.169294196962
0.2, 0.02, 0.0980066577841, 0.039933866159
0.4, 0.04, 0.0921060994003, 0.0782836684617
0.6, 0.06, 0.082533561491, 0.113528494679
0.8, 0.08, 0.0696706709347, 0.14427121818
1.0, 0.1, 0.0540302305868, 0.169294196962
1.2, 0.12, 0.0362357754477, 0.187607817193
1.4, 0.14, 0.01699671429, 0.198489945998
1.6, 0.16, -0.00291995223013, 0.201514720608
1.8, 0.18, -0.0227202094693, 0.196569526176
2.0, 0.2, -0.0416146836547, 0.183859485365
2.2, 0.22, -0.0588501117255, 0.163899280764
2.4, 0.24, -0.0737393715541, 0.13749263611
2.6, 0.26, -0.0856888753369, 0.105700274364
2.8, 0.28, -0.0942222340669, 0.0697976300312
3.0, 0.3, -0.09899924966, 0.031224001612

</pre>

<h4 id="recording">Recording</h4>
<p>Recording is as easy as using the <code>record</code> command. Providing an argument to the command, such as "example" will automatically start recording to a file called "example.csv" in the root folder of Stoolbotics.</p>
<h4 id="playback">Playback</h4>
<p>When playing back, all you need to do is use the <code>play</code> command with the filename you want to play back. For example, after recording to "example", you could type <code>play example.csv</code> to start playing what was recorded in the file.</p>
<h1 id="implementation">Implementation</h1>
<h2 id="overview">Overview</h2>
<p>Many technical challenges were overcome during the development of Stoolbotics. To take a look at the code yourself, here is a <a href="https://github.com/Stonelinks/Stoolbotics">link</a> to our GitHub. Choice algorithms and segments of the code will be explained and highlighted in this section.</p>
<h2 id="symbolics">Symbolics</h2>
<p>In order to properly make use of the configuration file, a symbolic solving engine had to me implemented in python to evaluate symbolic expressions. This means that given a symbolic string like <code>rot(h1, q1)</code>, the solver knows what the values of h1 and q1 are, and knows how to call the <code>rot()</code> function on them and generate a numeric answer. This solver is also used for evaluating joint parameters as a function of time. For example, given the joint parameter <code>.001*cos(t) + PI / 2</code>, spit out the correct answer for a given time <code>t</code>, and be able to recognize special cases of variables (in this case PI) that are not first order robot class variables.</p>
<p>To accomplish this, the robot object contains two dictionaries, <code>_d</code> and <code>syms</code>. As you probably could have guessed, <code>syms</code> contains the symbolic expressions much in the same state as they are in the configuration file. At every time step, this syms dictionary is parsed and evaluated into numeric values that are entered into the other dictionary, <code>_d</code>. This has the advantage of being able to set any string into the syms dictionary, and then being to immediately see its effect on the simulation without having to restart the simulator. This is indeed how the <code>set</code> command in the simulator works for setting variables inside the robot object.</p>
<p>Once every time-step, a function called <code>eval_syms()</code> is called. This function goes through the syms dictionary and uses string manipulation, substitution, collision detection (to make sure it can tell the difference between things like <code>l1</code> and <code>l10</code>) and finally the python <code>eval()</code> command to turn everything into numerical answers. These numerical answers are plugged into <code>_d</code>. It is from <code>_d</code> that the values for the various links are assigned, which ultimately dictate how the robot is drawn. Additionally, after evaluating <code>_d</code>, a function called <code>sync_d()</code> is called that simply uses the built in python <code>setattr()</code> function to make each entry in <code>_d</code> a class variable within the robot object instance. This allows calling of things like <code>robot.P01</code> to work instead of having to do <code>robot._d['P01']</code> every time you want to get at a variable inside <code>_d</code>.</p>
<p>Links are then constructed from all these variables as a convenient way to group related variables together. These links contain things like a joint's rotation matrix, position vector, joint parameter and joint axis. As we'll see later on, links are used mostly for accessing information about a robot arm.</p>
<h2 id="kinematics">Kinematics</h2>
<p>Once all symbolics for the robot are evaluated, it is actually pretty easy to solve for the forward kinematics of the arm. We use the product of exponentials approach to solve this. First, computing <code>R0T</code> is as simple as this:</p>
<pre>
robot.R0T = eye(3, 3)
for link in robot.links:
    robot.R0T = dot(robot.R0T, link.R)
</pre>

<p>As you can see, <code>R0T</code> starts out as the identity matrix. The links of the robot then are traversed in order from the base to the end, and along the way the current <code>R0T</code> is multiplied by the link's individual rotation matrix (which comes from <code>_d</code>). When this is all done, the resulting matrix is the correct <code>R0T</code>.</p>
<p>For positions, the algorithm is a bit more involved:</p>
<pre>
tmp = eye(3,3)
robot.P0T = zeros((3, 1))
p = None
for link in robot.links:
    robot.P0T += dot(tmp, link.P)
    tmp = dot(tmp, link.R)

p = (robot.P0T[0][0], robot.P0T[1][0], robot.P0T[2][0])
    self.verts.append(p)
</pre>

<p>First, a few variables are initialized. <code>tmp</code> is the temporary rotation matrix for all links up until the current iteration. It starts off as the identity matrix. Second, the overall position vector, <code>P0T</code>, starts out as a three by one zero vectors. Next, for each link in the robot arm, the representation of the link's position vector in terms of the base frame is added to the current position vector. This is done by using the dot product of the <code>tmp</code> rotation matrix and the link's position vector. The temporary rotation matrix is then updated, and the current position vector is appended to the <code>verts</code> list, which contains all the robot's vertices for the current time-step. This list is later used to draw things like the arm ghosts and trace.</p>
<h2 id="time-stepping">Time-stepping</h2>
<h2 id="drawing-the-robot">Drawing the Robot</h2>
<h3 id="joints">Joints</h3>
<p>When drawing the robot in a certain configuration in OpenGL, it is necessary to indicate which joints are rotational or prismatic. This is done inside the link class. Additionally, static links need to be distinguished from prismatic joints.</p>
<p>The drawing of rotational joints is done by using a <code>gluCylinder</code> along the axis of the joint. Unfortunately, OpenGL can only use <code>gluCylinder</code> along the Z axis. To accommodate this as our frame is independent of our rotation axis, we calculate the rotation need from the axis we want to draw along (some arbitrary axis - the rotation axis within our frame) to the Z vector within this same frame. Once this is rotated, drawing along the Z axis inside this new frame will draw along the rotation axis in the old frame. After the cylinder is drawn, end caps were drawn so enclose this cylinder by using a ‘for’ loop to iterate around a circle of points for gl_triangle_fan. This is done by using <code>glPushMatrix</code> and <code>glPopMatrix</code> with all the drawing taking place within the new calculated rotated matrix.</p>
<p>For prismatic joints, a method was developed to draw a rectangular prism along an arbitrary axis. This was done using a length and width/height (square area) as well as a start and end point. From there, a matrix is push onto the model view which is the rotation from the vector (end-start, same as shown above) to the Z axis. Then, a simple <code>gl_quads</code> was used to draw the 6 faces of the rectangular prism of the size provided and the matrix popped off. After the joint is drawn, the frame is rotated along the axis of rotation by the amount specified using <code>glRotate</code>. Then it is translated using <code>glTranslate</code> along the link which is representative in the rotated frame so no additional calculations are needed.</p>
<p>Now that the frame is at the next joint, the process is repeated till all joints are displayed. This process works off of the stack pushing and popping matrices. Joint 3 is related to Joint 2 which is a rotation and translation from Joint 1. Problems encountered while drawing the robot include the drawing of the <code>gluCylinder</code> along the axis or rotation as the rotation matrix needed to draw along the Z axis was causing issues due math errors in the passing of parameters to the cross and dot product. Another issue was trying to draw the entire robot in one frame as python was already calculating all the necessary information. This led to complexity issues that were troublesome to debug and even harder to comment and follow. The last troublesome part was using <code>glLoadMatrix</code> to force OpenGL to load a matrix that python had already calculated for internal purposes. The problem became known when rounding errors in python of the rotation matrix caused the determinate not to be 1.000 in all cases which would cause OpenGL to clip triangles of the screen and paint the pixels white.</p>
<h3 id="links">Links</h3>
<p>Links are drawn from the current frame after being rotated by the rotation matrix associated with the joint and the next joint location. This works due to links being relative to the current joint. A simple <code>gl_lines</code> from [0,0,0] to P(N-1)(N) where N is the next frame is drawn to symbolize a link. The existence of prismatic joints also play a role in how this line looks.</p>
<h2 id="terminal-implementation">Terminal Implementation</h2>
<p>The implementation of the OpenGL terminal was entirely non-trivial. However the algorithms that go into it will <strong>not</strong> be featured here, as they have nothing to do with robotics or graphics. Instead, what will be mentioned is the reasons behind implementing the terminal.</p>
<p>It was a carefully calculated design decision. The end goal was to have an easy way for users to enter commands to the simulator. Since OpenGL works by registering callback functions whenever an event occurs, the simulator has to ultimately submit control flow to the main OpenGL loop. This means that keyboard interrupts and stdin can never reach the program.</p>
<p>To get around this, we could have used a windowing toolkit. There are many windowing toolkits for python that we could have used: PyQT, wxPython, Tkinter, etc. However, not all of them support OpenGL widgets and they introduce portability issues when considering the cross platform nature of our simulator. Finally, windowing toolkits are complex beasts and there simply wasn't enough time to learn how to use them.</p>
<p>Therefore, the decision was made to implement a terminal inside OpenGL. This gave us the most control with regards to commands entered to the command prompt. Additionally, it makes the application more portable because no additional library dependencies are introduced.</p>
<h1 id="closing-remarks">Closing Remarks</h1>
<h2 id="future-improvements">Future Improvements</h2>
<p>There are a number of future improvements that can be made the simulator.</p>
<p>First, we really want to implement closed loop control from external applications such as MATLAB (IE not having to generate a file to be played back). In an effort to make this as cross platform as possible, the current plan is to do this using UDP sockets. Essentially, a program like MATLAB would send a list of joint angles to a UDP socket that the sumilator is listening on. Once the simulator receives the message, it would move the arm to that position.</p>
<p>Second, a user scripting environment would have been nice. This could allow people to write scripts that do things like inverse kinematics, workspace calculations, finding DH parameters, etc. The simulator would have to be modified to include hooks to look for scripts. In the case of inverse kinematics, a hook would need to look for a function and pass it forward kinematics information and expect to get a list of joint angles in return.</p></div>
</div>
</body>
</html>
